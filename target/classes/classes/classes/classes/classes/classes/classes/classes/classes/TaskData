Реализовать гонки
Даны три водителя с одинаковым навыком вождения (Этим параметром можно пренебречь). Они используют три разных автомобиля.
Трасса состоит из 20 прямых отрезков и поворотов между каждым отрезком. Каждый автомобиль едет один на трассе.
У каждого автомобиля есть 3 характеристики - Максимальная скорость, Ускорение и Маневренность.
Скорость измеряется в км\ч
Ускорение измеряется в м\с
Маневренность - коэффициент потери скорости в момент поворота от 0 до 1
при маневренности = 0,4 - во время поворота потеряет 60% скорости (Пример 10*0,4 = 4))
Каждый прямой отрезок - 2 км
Во время поворота
У каждого автомобиля есть своя особенность

1ый - если скорость автомобиля на момент поворота больше половины от максимальной - то он получает +0,5% от разницы
между половиной от максимальной и нынешней к маневренности на этот поворот следующим образом
(половина максимальной = 75. Нынешняя равна 90. Разница = 15. Маневренность до срабатывания = 0,5, стала = 0,575)

/** УСЛОВИЕ ВРОДЕ КАК НЕ СОВСЕМ КОРРЕКТНО, ПОСКОЛЬКУ В ПОЛОВИНЕ СЛУЧАЕВ ПОЛУЧАЕМ m>1
* (при больших значениях a, vTerminal и m)....
* так что выполним все-таки условие m<=1, иначе машину с водителем в какой-то момент разорвет. */

2ой - если скорость автомобиля после поворота меньше чем половина от максимальной,
то его ускорение на этом отрезке увеличивается в 2 раза

3ий - если автомобиль в момент поворота достиг своей максимальной скорости, то его максимальная скорость
увеличивается на 10% до конца гонки.

После реализации создать несколько наборов автомобилей с разными характеристиками и прогнать их на трассе
вывести результаты на экран - в виде списка записей следующего типа:
Автомобиль 1 прошел трассу за 10 минут 5 секунд
отсортированного от меньшего результата к большему. Алгоритм сортировки реализовать свой - без использования
сторонних библиотек

Формулы для решения:
Для каждого автомобиля v0 = 0 вначале и v0!=0 на каждом следующем отрезке. s = v0*t + a*t*t/2; - это для каждого отрезка.
 Для v0 = 0: s=at^2/2; s=v^2/2a; a=2s/t^2;

    /** all formulae used in the class cars.Vehicle:
     *      s = a*t^2/2+v0*t;
     *      v = v0+a*t;
     *      s = (v^2-v0^2)/(2*a);
     *      t=s/v0 (if a = 0);
     *      D = b^2-4*a*c;
     *      x1 = (-b+sqrtD)/(2*a);
     *
     *      Creating necessary variables:
     *      double t = the whole time of the segment passage, sec;
     *      double v0 = speed at the beginning of segment, m/sec (Note! not km/h!);
     *      double vTerminal = the final speed at the end of the segment, m/sec (Note! not km/h!);
     */
        //На первом отрезке пути начальная скорость initialSpeed=0, а на остальных initialSpeed=v[i]
        // после прохождения i поворота. Это мы учтем, введя переменную terminalSpeed (скорость перед поворотом)
        // и далее используя ее в методах класса-наследника.

        //После момента достижения максимальной скорости fullSpeed движение из равноускоренного становится линейным.
        //Формула для вычисления времени, необходимого для достижения максимальной скорости:
        /** vX = initialSpeed+acceleration*tX; */ //здесь vX - скорость в произвольный момент времени tX
        //Если максимальная скорость на данном сегменте пути s не достигается, то полное время t = tFull прохождения
        // данного сегмента s можно вычислить, решив квадратное уравнение (из формулы s = acceleration*t^2/2+initialSpeed*t):
        /** acceleration*tFull^2/2+initialSpeed*tFull+(-s) = 0; */
        //При этом ускорение а никогда не будет отрицательным (как в случае броска камня вверх), s>0 по умолчанию,
        // так что дискриминант уравнения Discriminant = initialSpeed^2-4*acceleration*(-s) всегда >0
        // (исключение: acceleration==0&&initialSpeed==0 - см.ниже);
        //Кроме того, отрицательное решение уравнения нас не интересует (это для параллельного мира).

        //Далее: если получившаяся greatestPossibleSpeed>fullSpeed, то нужно найти момент tX,
        при котором наступит условие vX==fullSpeed,
             //и с этого момента движение станет линейным. Условие: initialSpeed+acceleration*tX = fullSpeed; отсюда
             /** tX = (fullSpeed-initialSpeed)/acceleration - время достижения максимальной скорости,
             если она достигается на данном сегменте пути/ */
             //За это время будет пройден путь: sX = initialSpeed*tX+acceleration*tX^2/2, то есть:
             /** sX = initialSpeed*(fullSpeed-initialSpeed)/acceleration + (fullSpeed-initialSpeed)^2/(2*acceleration)
             - путь, пройденный с ускорением до момента достижения максимальной скорости */
             //вот не помню я, какая операция приоритетнее - деление или умножение?
             // поэтому пишу на всякий случай (2*а) в скобках.
             // Ага! здесь действует ассоциативность операторов с равным приоритетом, то есть они выполняются
             // слева направо, так что скобки нужны!
             // Тогда время прохождения оставшегося пути:
             /** tRemain = (s-sX)/vX = (s-sX)/fullSpeed; и t = tX+tRemain; */

  //Note: величину spacingX можно было бы также вывести из формулы s = (v^2-initialSpeed^2)/(2*acceleration); тогда она бы выглядела так:
                  //spacingX = (Math.pow(fullSpeed,2)-Math.pow(initialSpeed,2))/(2*acceleration); результат ровно тот же.
cars.MashkaCar:
            // Условие для изменения v0 для следующего шага: "если скорость автомобиля на момент поворота больше половины от
            // максимальной - то он получает +0,5% от разницы между половиной от максимальной и нынешней к маневренности
            // на этот поворот следующим образом (половина максимальной = 75. Нынешняя равна 90. Разница = 15.
            // Маневренность до срабатывания = 0,5, стала = 0,575)..." - УСЛОВИЕ ВРОДЕ КАК НЕ СОВСЕМ КОРРЕКТНО,
            // ПОСКОЛЬКУ В ПОЛОВИНЕ СЛУЧАЕВ ПОЛУЧАЕМ mobility>1(при больших значениях acceleration, vTerminal и mobility).... Так что выполним
            // все-таки условие mobility<=1, иначе машину с водителем в какой-то момент разорвет.
cars.BmwCar
            // Условие для изменения v0 для следующего шага: "2ой - если
            // скорость автомобиля после поворота меньше чем половина от максимальной,
            // то его ускорение на этом отрезке увеличивается в 2 раза
            /** если я правильно понял условие, ускорение не ограничивается величиной а*2,
             * а растет до тех пор, пока (vTerminal<=vMax) = true */
FerraryCar
            // Условие для изменения v0 для следующего шага: "3ий - если автомобиль
            // в момент поворота достиг своей максимальной скорости, то его максимальная скорость
            // увеличивается на 10% до конца гонки"
            /** Я понял фразу "до конца гонки" следующим образом: максимальная скорость может увеличиться
             * на 10% один раз, и останется такой до конца гонки. Потому что, если она будет увеличиваться
             * на 10% каждый раз, как автомобиль достигает макс.скорости, то при хорошем ускорении автомобиль
             * через пару кругов разовьет первую космическую (предела-то по макс. скорости нет!)
             * и выйдет на орбиту. Чтобы не потерять водителя в вакууме, я выбрал условие "1 раз до конца" */
после break: //в этом месте цикл ломаем и начинаем новый цикл без этого условия, поскольку
             // макс. скорость увеличивается 1 раз до конца поездки
             //условие: если предыдущий цикл полностью прошел до конца и vTerminal != vMax (k=0),
             // или же vTerminal = vMax только после прохождения финишного 20-го круга (i=19, k=20),
             // то следующий цикл не должен начаться: